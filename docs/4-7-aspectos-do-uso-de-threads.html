<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-03-22T13:37:38.521148825"><title>4.7 Aspectos do Uso de Threads | Operating System</title><script type="application/json" id="virtual-toc-data">[{"id":"1-chamadas-de-sistema-fork-e-exec","level":0,"title":"1. Chamadas de Sistema fork() e exec()","anchor":"#1-chamadas-de-sistema-fork-e-exec"},{"id":"2-cancelamento-de-threads","level":0,"title":"2. Cancelamento de Threads","anchor":"#2-cancelamento-de-threads"},{"id":"3-tratamento-de-sinais","level":0,"title":"3. Tratamento de Sinais","anchor":"#3-tratamento-de-sinais"},{"id":"4-bancos-de-threads","level":0,"title":"4. Bancos de Threads","anchor":"#4-bancos-de-threads"},{"id":"5-dados-espec-ficos-da-thread","level":0,"title":"5. Dados Específicos da Thread","anchor":"#5-dados-espec-ficos-da-thread"},{"id":"6-ativa-es-do-escalonador-scheduler-activations","level":0,"title":"6. Ativações do Escalonador (Scheduler Activations)","anchor":"#6-ativa-es-do-escalonador-scheduler-activations"},{"id":"resumo","level":0,"title":"Resumo","anchor":"#resumo"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b725/app.css" rel="stylesheet"><link rel="icon" type="image/svg" sizes="16x16" href="images/logo-primary.svg"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="4.7 Aspectos do Uso de Threads | Operating System"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Operating System Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/4-7-aspectos-do-uso-de-threads.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="4.7 Aspectos do Uso de Threads | Operating System"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/4-7-aspectos-do-uso-de-threads.html#webpage",
    "url": "writerside-documentation/4-7-aspectos-do-uso-de-threads.html",
    "name": "4.7 Aspectos do Uso de Threads | Operating System",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Operating System Help"
}</script><!-- End Schema.org --></head><body data-id="4-7-Aspectos-do-Uso-de-Threads" data-main-title="4.7 Aspectos do Uso de Threads" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Workers and Scheduler///Domus 4///a.md|Threads"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Operating System  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="4-7-Aspectos-do-Uso-de-Threads" id="4-7-Aspectos-do-Uso-de-Threads.md">4.7 Aspectos do Uso de Threads</h1><p id="j442xi_3">Vamos explorar os <span class="control" id="j442xi_14">aspectos do uso de threads</span> de forma detalhada, com exemplos pr&aacute;ticos, analogias e diagramas para facilitar o entendimento.</p><ol class="list _decimal" id="j442xi_5" type="1"><li class="list__item" id="j442xi_15"><p id="j442xi_21"><span class="control" id="j442xi_23">Chamadas de Sistema</span>:</p><ul class="list _bullet" id="j442xi_22"><li class="list__item" id="j442xi_24"><p id="j442xi_25">Aborda o comportamento de <code class="code" id="j442xi_26">fork()</code> e <code class="code" id="j442xi_27">exec()</code> em programas multithread, destacando as duas vers&otilde;es de <code class="code" id="j442xi_28">fork()</code> e o impacto de <code class="code" id="j442xi_29">exec()</code>.</p></li></ul></li><li class="list__item" id="j442xi_16"><p id="j442xi_30"><span class="control" id="j442xi_32">Cancelamento de Threads</span>:</p><ul class="list _bullet" id="j442xi_31"><li class="list__item" id="j442xi_33"><p id="j442xi_34">Discute as t&eacute;cnicas de cancelamento ass&iacute;ncrono e adiado, com exemplos em Java usando <code class="code" id="j442xi_35">interrupt()</code> e <code class="code" id="j442xi_36">isInterrupted()</code>.</p></li></ul></li><li class="list__item" id="j442xi_17"><p id="j442xi_37"><span class="control" id="j442xi_39">Tratamento de Sinais</span>:</p><ul class="list _bullet" id="j442xi_38"><li class="list__item" id="j442xi_40"><p id="j442xi_41">Explora como os sinais s&atilde;o entregues em programas multithread, diferenciando sinais s&iacute;ncronos e ass&iacute;ncronos, e como s&atilde;o tratados em sistemas UNIX e Windows.</p></li></ul></li><li class="list__item" id="j442xi_18"><p id="j442xi_42"><span class="control" id="j442xi_44">Bancos de Threads</span>:</p><ul class="list _bullet" id="j442xi_43"><li class="list__item" id="j442xi_45"><p id="j442xi_46">Explica a cria&ccedil;&atilde;o e uso de bancos de threads para melhorar a efici&ecirc;ncia e o controle de recursos, com exemplos pr&aacute;ticos em Java.</p></li></ul></li><li class="list__item" id="j442xi_19"><p id="j442xi_47"><span class="control" id="j442xi_49">Dados Espec&iacute;ficos da Thread</span>:</p><ul class="list _bullet" id="j442xi_48"><li class="list__item" id="j442xi_50"><p id="j442xi_51">Introduz o conceito de <code class="code" id="j442xi_52">ThreadLocal</code> para armazenar dados privados por thread, &uacute;til em cen&aacute;rios como processamento de transa&ccedil;&otilde;es.</p></li></ul></li><li class="list__item" id="j442xi_20"><p id="j442xi_53"><span class="control" id="j442xi_55">Ativa&ccedil;&otilde;es do Escalonador</span>:</p><ul class="list _bullet" id="j442xi_54"><li class="list__item" id="j442xi_56"><p id="j442xi_57">Descreve a comunica&ccedil;&atilde;o entre threads de usu&aacute;rio e kernel por meio de LWPs e upcalls, permitindo ajustes din&acirc;micos no escalonamento.</p></li></ul></li></ol><section class="chapter"><h2 id="1-chamadas-de-sistema-fork-e-exec" data-toc="1-chamadas-de-sistema-fork-e-exec"><span class="control" id="j442xi_63">1. Chamadas de Sistema <code class="code" id="j442xi_64">fork()</code> e <code class="code" id="j442xi_65">exec()</code></span></h2><section class="chapter"><h3 id="problema" data-toc="problema"><span class="control" id="j442xi_68">Problema</span></h3><p id="j442xi_67">Quando uma thread em um programa multithread chama <code class="code" id="j442xi_69">fork()</code>, o novo processo deve duplicar todas as threads ou apenas a thread que chamou <code class="code" id="j442xi_70">fork()</code>? Al&eacute;m disso, como a chamada <code class="code" id="j442xi_71">exec()</code> afeta as threads?</p></section><section class="chapter"><h3 id="solu-o" data-toc="solu-o"><span class="control" id="j442xi_74">Solu&ccedil;&atilde;o</span></h3><ul class="list _bullet" id="j442xi_73"><li class="list__item" id="j442xi_75"><p id="j442xi_77"><span class="control" id="j442xi_79">Duas vers&otilde;es de <code class="code" id="j442xi_80">fork()</code></span>:</p><ol class="list _decimal" id="j442xi_78" type="1"><li class="list__item" id="j442xi_81"><p id="j442xi_83"><span class="control" id="j442xi_84">Duplicar todas as threads</span>: O novo processo ter&aacute; uma c&oacute;pia de todas as threads do processo original.</p></li><li class="list__item" id="j442xi_82"><p id="j442xi_85"><span class="control" id="j442xi_86">Duplicar apenas a thread que chamou <code class="code" id="j442xi_87">fork()</code></span>: O novo processo ter&aacute; apenas uma thread.</p></li></ol></li><li class="list__item" id="j442xi_76"><p id="j442xi_88"><span class="control" id="j442xi_90">Escolha da vers&atilde;o</span>:</p><ul class="list _bullet" id="j442xi_89"><li class="list__item" id="j442xi_91"><p id="j442xi_93">Se <code class="code" id="j442xi_94">exec()</code> for chamado logo ap&oacute;s <code class="code" id="j442xi_95">fork()</code>, duplicar todas as threads &eacute; desnecess&aacute;rio, pois o programa ser&aacute; substitu&iacute;do.</p></li><li class="list__item" id="j442xi_92"><p id="j442xi_96">Se <code class="code" id="j442xi_97">exec()</code> n&atilde;o for chamado, o novo processo deve duplicar todas as threads para manter a funcionalidade.</p></li></ul></li></ul></section><section class="chapter"><h3 id="exemplo-em-c" data-toc="exemplo-em-c"><span class="control" id="j442xi_100">Exemplo em C</span></h3><div class="code-block" data-lang="c">
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;

void* thread_func(void* arg) {
    printf(&quot;Thread filha em execução\n&quot;);
    sleep(2);
    printf(&quot;Thread filha terminou\n&quot;);
    return NULL;
}

int main() {
    pthread_t thread;
    pthread_create(&amp;thread, NULL, thread_func, NULL);

    pid_t pid = fork();
    if (pid == 0) { // Processo filho
        printf(&quot;Processo filho criado\n&quot;);
        execlp(&quot;ls&quot;, &quot;ls&quot;, NULL); // Substitui o processo filho
    } else if (pid &gt; 0) { // Processo pai
        printf(&quot;Processo pai esperando\n&quot;);
        pthread_join(thread, NULL);
    }

    return 0;
}
</div></section><section class="chapter"><h3 id="explica-o" data-toc="explica-o"><span class="control" id="j442xi_104">Explica&ccedil;&atilde;o</span></h3><ul class="list _bullet" id="j442xi_102"><li class="list__item" id="j442xi_105"><p id="j442xi_106">O processo filho criado por <code class="code" id="j442xi_107">fork()</code> substitui seu espa&ccedil;o de mem&oacute;ria com <code class="code" id="j442xi_108">exec()</code>, ent&atilde;o apenas a thread que chamou <code class="code" id="j442xi_109">fork()</code> &eacute; duplicada.</p></li></ul></section></section><section class="chapter"><h2 id="2-cancelamento-de-threads" data-toc="2-cancelamento-de-threads"><span class="control" id="j442xi_115">2. Cancelamento de Threads</span></h2><section class="chapter"><h3 id="problema_5" data-toc="problema_5"><span class="control" id="j442xi_118">Problema</span></h3><p id="j442xi_117">Cancelar uma thread antes que ela termine sua execu&ccedil;&atilde;o pode ser necess&aacute;rio, mas isso pode causar problemas se a thread estiver manipulando recursos compartilhados.</p></section><section class="chapter"><h3 id="solu-o_5" data-toc="solu-o_5"><span class="control" id="j442xi_121">Solu&ccedil;&atilde;o</span></h3><ul class="list _bullet" id="j442xi_120"><li class="list__item" id="j442xi_122"><p id="j442xi_124"><span class="control" id="j442xi_125">Cancelamento Ass&iacute;ncrono</span>: A thread &eacute; terminada imediatamente.</p></li><li class="list__item" id="j442xi_123"><p id="j442xi_126"><span class="control" id="j442xi_127">Cancelamento Adiado</span>: A thread verifica periodicamente se deve ser cancelada, permitindo uma finaliza&ccedil;&atilde;o segura.</p></li></ul></section><section class="chapter"><h3 id="exemplo-em-java" data-toc="exemplo-em-java"><span class="control" id="j442xi_130">Exemplo em Java</span></h3><div class="code-block" data-lang="java">
class InterruptibleThread implements Runnable {
    public void run() {
        while (!Thread.currentThread().isInterrupted()) {
            System.out.println(&quot;Thread em execução&quot;);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println(&quot;Thread interrompida&quot;);
                Thread.currentThread().interrupt(); // Restaura o status de interrupção
            }
        }
        System.out.println(&quot;Thread terminada&quot;);
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new InterruptibleThread());
        thread.start();

        Thread.sleep(3000); // Espera 3 segundos
        thread.interrupt(); // Interrompe a thread
    }
}
</div></section><section class="chapter"><h3 id="explica-o_4" data-toc="explica-o_4"><span class="control" id="j442xi_134">Explica&ccedil;&atilde;o</span></h3><ul class="list _bullet" id="j442xi_132"><li class="list__item" id="j442xi_135"><p id="j442xi_136">A thread verifica seu status de interrup&ccedil;&atilde;o com <code class="code" id="j442xi_137">isInterrupted()</code> e termina de forma segura.</p></li></ul></section></section><section class="chapter"><h2 id="3-tratamento-de-sinais" data-toc="3-tratamento-de-sinais"><span class="control" id="j442xi_143">3. Tratamento de Sinais</span></h2><section class="chapter"><h3 id="problema_4" data-toc="problema_4"><span class="control" id="j442xi_146">Problema</span></h3><p id="j442xi_145">Em programas multithread, os sinais podem ser entregues a uma thread espec&iacute;fica ou a todas as threads, dependendo do tipo de sinal.</p></section><section class="chapter"><h3 id="solu-o_4" data-toc="solu-o_4"><span class="control" id="j442xi_149">Solu&ccedil;&atilde;o</span></h3><ul class="list _bullet" id="j442xi_148"><li class="list__item" id="j442xi_150"><p id="j442xi_152"><span class="control" id="j442xi_153">Sinais S&iacute;ncronos</span>: Entregues &agrave; thread que causou o sinal.</p></li><li class="list__item" id="j442xi_151"><p id="j442xi_154"><span class="control" id="j442xi_155">Sinais Ass&iacute;ncronos</span>: Podem ser entregues a todas as threads ou a uma thread espec&iacute;fica.</p></li></ul></section><section class="chapter"><h3 id="exemplo-em-c-unix" data-toc="exemplo-em-c-unix"><span class="control" id="j442xi_158">Exemplo em C (UNIX)</span></h3><div class="code-block" data-lang="c">
#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

void handle_signal(int sig) {
    printf(&quot;Sinal %d recebido pela thread %ld\n&quot;, sig, (long)pthread_self());
}

void* thread_func(void* arg) {
    signal(SIGUSR1, handle_signal);
    while (1) {
        sleep(1);
    }
    return NULL;
}

int main() {
    pthread_t thread1, thread2;
    pthread_create(&amp;thread1, NULL, thread_func, NULL);
    pthread_create(&amp;thread2, NULL, thread_func, NULL);

    sleep(2);
    pthread_kill(thread1, SIGUSR1); // Envia sinal para thread1
    pthread_kill(thread2, SIGUSR1); // Envia sinal para thread2

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    return 0;
}
</div></section><section class="chapter"><h3 id="explica-o_3" data-toc="explica-o_3"><span class="control" id="j442xi_162">Explica&ccedil;&atilde;o</span></h3><ul class="list _bullet" id="j442xi_160"><li class="list__item" id="j442xi_163"><p id="j442xi_164">O sinal <code class="code" id="j442xi_165">SIGUSR1</code> &eacute; enviado para threads espec&iacute;ficas usando <code class="code" id="j442xi_166">pthread_kill()</code>.</p></li></ul></section></section><section class="chapter"><h2 id="4-bancos-de-threads" data-toc="4-bancos-de-threads"><span class="control" id="j442xi_172">4. Bancos de Threads</span></h2><section class="chapter"><h3 id="problema_3" data-toc="problema_3"><span class="control" id="j442xi_175">Problema</span></h3><p id="j442xi_174">Criar uma nova thread para cada requisi&ccedil;&atilde;o em um servidor pode ser ineficiente e consumir muitos recursos.</p></section><section class="chapter"><h3 id="solu-o_3" data-toc="solu-o_3"><span class="control" id="j442xi_178">Solu&ccedil;&atilde;o</span></h3><ul class="list _bullet" id="j442xi_177"><li class="list__item" id="j442xi_179"><p id="j442xi_180"><span class="control" id="j442xi_181">Bancos de Threads</span>: Um conjunto de threads &eacute; criado no in&iacute;cio e reutilizado para atender requisi&ccedil;&otilde;es.</p></li></ul></section><section class="chapter"><h3 id="exemplo-em-java_2" data-toc="exemplo-em-java_2"><span class="control" id="j442xi_184">Exemplo em Java</span></h3><div class="code-block" data-lang="java">
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

class Task implements Runnable {
    private int id;

    public Task(int id) {
        this.id = id;
    }

    public void run() {
        System.out.println(&quot;Task &quot; + id + &quot; executada por &quot; + Thread.currentThread().getName());
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3); // Banco com 3 threads

        for (int i = 1; i &lt;= 10; i++) {
            executor.execute(new Task(i));
        }

        executor.shutdown();
    }
}
</div></section><section class="chapter"><h3 id="explica-o_2" data-toc="explica-o_2"><span class="control" id="j442xi_188">Explica&ccedil;&atilde;o</span></h3><ul class="list _bullet" id="j442xi_186"><li class="list__item" id="j442xi_189"><p id="j442xi_190">O banco de threads com 3 threads executa 10 tarefas, reutilizando as threads dispon&iacute;veis.</p></li></ul></section></section><section class="chapter"><h2 id="5-dados-espec-ficos-da-thread" data-toc="5-dados-espec-ficos-da-thread"><span class="control" id="j442xi_196">5. Dados Espec&iacute;ficos da Thread</span></h2><section class="chapter"><h3 id="problema_2" data-toc="problema_2"><span class="control" id="j442xi_199">Problema</span></h3><p id="j442xi_198">Threads compartilham dados globais, mas &agrave;s vezes cada thread precisa de sua pr&oacute;pria c&oacute;pia de dados.</p></section><section class="chapter"><h3 id="solu-o_2" data-toc="solu-o_2"><span class="control" id="j442xi_202">Solu&ccedil;&atilde;o</span></h3><ul class="list _bullet" id="j442xi_201"><li class="list__item" id="j442xi_203"><p id="j442xi_204"><span class="control" id="j442xi_205">ThreadLocal</span>: Permite que cada thread tenha sua pr&oacute;pria c&oacute;pia de dados.</p></li></ul></section><section class="chapter"><h3 id="exemplo-em-java_1" data-toc="exemplo-em-java_1"><span class="control" id="j442xi_208">Exemplo em Java</span></h3><div class="code-block" data-lang="java">
class ThreadLocalExample {
    private static ThreadLocal&lt;Integer&gt; threadLocal = ThreadLocal.withInitial(() -&gt; 0);

    public static void main(String[] args) {
        Runnable task = () -&gt; {
            int value = threadLocal.get();
            threadLocal.set(value + 1);
            System.out.println(Thread.currentThread().getName() + &quot;: &quot; + threadLocal.get());
        };

        Thread thread1 = new Thread(task);
        Thread thread2 = new Thread(task);

        thread1.start();
        thread2.start();
    }
}
</div></section><section class="chapter"><h3 id="explica-o_1" data-toc="explica-o_1"><span class="control" id="j442xi_212">Explica&ccedil;&atilde;o</span></h3><ul class="list _bullet" id="j442xi_210"><li class="list__item" id="j442xi_213"><p id="j442xi_214">Cada thread mant&eacute;m sua pr&oacute;pria c&oacute;pia do valor em <code class="code" id="j442xi_215">threadLocal</code>.</p></li></ul></section></section><section class="chapter"><h2 id="6-ativa-es-do-escalonador-scheduler-activations" data-toc="6-ativa-es-do-escalonador-scheduler-activations"><span class="control" id="j442xi_220">6. Ativa&ccedil;&otilde;es do Escalonador (Scheduler Activations)</span></h2><section class="chapter"><h3 id="problema_1" data-toc="problema_1"><span class="control" id="j442xi_223">Problema</span></h3><p id="j442xi_222">A comunica&ccedil;&atilde;o entre threads de usu&aacute;rio e threads do kernel pode ser necess&aacute;ria para ajustar dinamicamente o n&uacute;mero de threads de kernel.</p></section><section class="chapter"><h3 id="solu-o_1" data-toc="solu-o_1"><span class="control" id="j442xi_226">Solu&ccedil;&atilde;o</span></h3><ul class="list _bullet" id="j442xi_225"><li class="list__item" id="j442xi_227"><p id="j442xi_229"><span class="control" id="j442xi_230">Processos Leves (LWPs)</span>: Estruturas intermedi&aacute;rias que permitem a comunica&ccedil;&atilde;o entre threads de usu&aacute;rio e threads do kernel.</p></li><li class="list__item" id="j442xi_228"><p id="j442xi_231"><span class="control" id="j442xi_232">Upcalls</span>: O kernel notifica a aplica&ccedil;&atilde;o sobre eventos, como o bloqueio de uma thread.</p></li></ul></section><section class="chapter"><h3 id="exemplo-conceitual" data-toc="exemplo-conceitual"><span class="control" id="j442xi_236">Exemplo Conceitual</span></h3><ol class="list _decimal" id="j442xi_234" type="1"><li class="list__item" id="j442xi_237"><p id="j442xi_240">O kernel aloca LWPs para a aplica&ccedil;&atilde;o.</p></li><li class="list__item" id="j442xi_238"><p id="j442xi_241">Quando uma thread de usu&aacute;rio &eacute; bloqueada, o kernel faz um upcall para a aplica&ccedil;&atilde;o.</p></li><li class="list__item" id="j442xi_239"><p id="j442xi_242">A aplica&ccedil;&atilde;o salva o estado da thread bloqueada e escalona outra thread no LWP dispon&iacute;vel.</p></li></ol></section></section><section class="chapter"><h2 id="resumo" data-toc="resumo"><span class="control" id="j442xi_245">Resumo</span></h2><div class="table-wrapper"><table class="wide" id="j442xi_244"><thead><tr class="ijRowHead" id="j442xi_246"><th id="j442xi_253"><p>T&oacute;pico</p></th><th id="j442xi_254"><p>Descri&ccedil;&atilde;o</p></th></tr></thead><tbody><tr id="j442xi_247"><td id="j442xi_255"><p><span class="control" id="j442xi_257"><code class="code" id="j442xi_258">fork()</code> e <code class="code" id="j442xi_259">exec()</code></span></p></td><td id="j442xi_256"><p>Duplica&ccedil;&atilde;o de threads e substitui&ccedil;&atilde;o de processos.</p></td></tr><tr id="j442xi_248"><td id="j442xi_260"><p><span class="control" id="j442xi_262">Cancelamento de Threads</span></p></td><td id="j442xi_261"><p>Ass&iacute;ncrono (imediato) ou adiado (seguro).</p></td></tr><tr id="j442xi_249"><td id="j442xi_263"><p><span class="control" id="j442xi_265">Tratamento de Sinais</span></p></td><td id="j442xi_264"><p>Entregues a threads espec&iacute;ficas ou a todas as threads.</p></td></tr><tr id="j442xi_250"><td id="j442xi_266"><p><span class="control" id="j442xi_268">Bancos de Threads</span></p></td><td id="j442xi_267"><p>Reutiliza&ccedil;&atilde;o de threads para melhorar efici&ecirc;ncia.</p></td></tr><tr id="j442xi_251"><td id="j442xi_269"><p><span class="control" id="j442xi_271">Dados Espec&iacute;ficos</span></p></td><td id="j442xi_270"><p>Uso de <code class="code" id="j442xi_272">ThreadLocal</code> para dados privados por thread.</p></td></tr><tr id="j442xi_252"><td id="j442xi_273"><p><span class="control" id="j442xi_275">Ativa&ccedil;&otilde;es do Escalonador</span></p></td><td id="j442xi_274"><p>Comunica&ccedil;&atilde;o entre threads de usu&aacute;rio e kernel via LWPs e upcalls.</p></td></tr></tbody></table></div></section><div class="last-modified">Last modified: 22 março 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="4-6-threads-em-java.html" class="navigation-links__prev">4.6 Threads em Java</a><a href="4-8-exemplos-em-sistemas-operacionais.html" class="navigation-links__next">4.8 Exemplos em Sistemas Operacionais</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b725/app.js"></script></body></html>