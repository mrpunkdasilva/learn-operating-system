# 7.3 Estrutura de diret√≥rio e disco

## **1. Sistemas de Arquivos Especiais (Solaris e Outros)**

### **1.1 Tipos de Sistemas de Arquivos**
| **Tipo**       | **Descri√ß√£o**                                  | **Analogia Minecraft**                     |
|----------------|-----------------------------------------------|--------------------------------------------|
| **tmpfs**      | Sistema tempor√°rio em mem√≥ria vol√°til         | Ba√∫ que some ao sair do mundo              |
| **objfs**      | Interface para s√≠mbolos do kernel             | Livro de receitas de crafting do sistema   |
| **ctfs**       | Armazena contratos de inicializa√ß√£o           | Painel de controle do servidor             |
| **lofs**       | Sistema de "loop back" para redirecionamento  | Portal que leva a outro ba√∫                |
| **procfs**     | Apresenta processos como arquivos             | Painel de status dos jogadores             |
| **ufs/zfs**    | Sistemas de arquivos de uso geral             | Ba√∫s convencionais                         |

## **2. Estruturas de Diret√≥rios**

### **2.1. Diret√≥rio de √önico N√≠vel**

### **Caracter√≠sticas**
- Todos os arquivos em um √∫nico diret√≥rio
- Nomes de arquivos devem ser √∫nicos
- Sem organiza√ß√£o hier√°rquica

**Problemas**: 
- Colis√µes de nomes entre usu√°rios
- Dificuldade de organiza√ß√£o para muitos arquivos

```mermaid
graph TD
    R[(Diret√≥rio Raiz)] --> F1[arquivo1.txt]
    R --> F2[arquivo2.log]
    R --> F3[imagem.png]
```

#### **Implementa√ß√£o Java** {id="implementa-o-java_1"}
```java
import java.io.File;
import java.util.Arrays;

public class SingleLevelDirectory {
    public static void main(String[] args) {
        File root = new File("/tmp/root_dir");
        root.mkdir();
        
        // Criar arquivos
        Arrays.asList("file1.txt", "file2.dat", "document.pdf").forEach(f -> {
            try {
                new File(root, f).createNewFile();
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
        
        // Listar conte√∫do
        System.out.println("Arquivos no diret√≥rio √∫nico:");
        Arrays.stream(root.listFiles()).forEach(System.out::println);
    }
}
```

### **2.2 Diret√≥rio de Dois N√≠veis**

#### **Caracter√≠sticas** {id="caracter-sticas_4"}
- Diret√≥rio mestre (MFD) cont√©m diret√≥rios de usu√°rios (UFD)
- Isolamento entre usu√°rios
- Resolve problema de colis√£o de nomes

```mermaid
graph TD
    MFD[Master File Directory] --> UFD1[Usu√°rio1]
    MFD --> UFD2[Usu√°rio2]
    
    UFD1 --> F1[doc1.txt]
    UFD1 --> F2[config.cfg]
    UFD2 --> F3[doc1.txt]
    UFD2 --> F4[game.save]
```

#### **Implementa√ß√£o Java** {id="implementa-o-java_2"}
```java
import java.io.File;
import java.util.HashMap;
import java.util.Map;

public class TwoLevelDirectory {
    private static Map<String, File> userDirs = new HashMap<>();
    
    public static void main(String[] args) {
        // Criar estrutura
        File mfd = new File("/tmp/mfd");
        mfd.mkdir();
        
        // Adicionar usu√°rios
        addUser("alice");
        addUser("bob");
        
        // Criar arquivos
        createFile("alice", "notes.txt");
        createFile("bob", "notes.txt"); // Nome repetido permitido
        
        System.out.println("Estrutura criada em: " + mfd.getAbsolutePath());
    }
    
    private static void addUser(String username) {
        File userDir = new File("/tmp/mfd/" + username);
        userDir.mkdir();
        userDirs.put(username, userDir);
    }
    
    private static void createFile(String user, String filename) {
        try {
            new File(userDirs.get(user), filename).createNewFile();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### **2.3 Estrutura em √Årvore**

#### **Caracter√≠sticas** {id="caracter-sticas_1"}
- Hierarquia ilimitada de subdiret√≥rios
- Caminhos absolutos e relativos
- Organiza√ß√£o l√≥gica de arquivos

```mermaid
graph TD
    R[(/)] --> etc
    R --> home
    R --> usr
    
    home --> user1
    home --> user2
    
    user1 --> docs
    user1 --> downloads
    
    docs --> F1[relatorio.pdf]
    downloads --> F2[arquivo.zip]
    
    etc --> F3[config.cfg]
```

#### **Implementa√ß√£o Java (usando NIO)**
```java
import java.nio.file.*;

public class TreeStructure {
    public static void main(String[] args) throws Exception {
        Path root = Paths.get("/tmp/fs_tree");
        
        // Criar estrutura
        Files.createDirectories(root.resolve("home/user1/documents"));
        Files.createDirectories(root.resolve("home/user2/downloads"));
        Files.createDirectories(root.resolve("etc/config"));
        
        // Criar arquivos
        Files.write(root.resolve("home/user1/documents/notes.txt"), 
                   "Conte√∫do".getBytes());
        
        // Listar recursivamente
        System.out.println("Estrutura completa:");
        Files.walk(root).forEach(System.out::println);
    }
}
```

### **2.4 Grafo Ac√≠clico**

#### **Caracter√≠sticas** {id="caracter-sticas_2"}
- Permite compartilhamento via links
- Estrutura n√£o-linear sem ciclos
- Contagem de refer√™ncias para exclus√£o segura

```mermaid
graph TD
    A((/)) --> B[home]
    A --> C[shared]
    
    B --> D[user1]
    B --> E[user2]
    
    D --> F[doc.txt]
    E --> G[doc.txt]
    
    C --> H[shared_file.dat]
    
    D -->|link| H
    E -->|link| H
```

#### **Implementa√ß√£o Java**
```java
import java.nio.file.*;
import java.io.IOException;

public class AcyclicGraph {
    public static void main(String[] args) {
        Path base = Paths.get("/tmp/fs_graph");
        
        try {
            // Criar estrutura base
            Path sharedFile = base.resolve("shared/data.bin");
            Files.createDirectories(sharedFile.getParent());
            Files.write(sharedFile, "Dados compartilhados".getBytes());
            
            // Criar links
            Path user1Link = base.resolve("home/user1/link_to_shared");
            Path user2Link = base.resolve("home/user2/shared_data");
            
            Files.createSymbolicLink(user1Link, sharedFile);
            Files.createSymbolicLink(user2Link, sharedFile);
            
            // Verificar links
            System.out.println("Link 1 aponta para: " + Files.readSymbolicLink(user1Link));
            System.out.println("Link 2 aponta para: " + Files.readSymbolicLink(user2Link));
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### **2.5 Grafo Geral**

#### **Caracter√≠sticas** {id="caracter-sticas_3"}
- Permite ciclos (autorrefer√™ncias)
- Requer coleta de lixo para gerenciamento
- Raro em sistemas de arquivos reais

```mermaid
graph TD
    A[(/)] --> B[dir1]
    A --> C[dir2]
    
    B --> D[file1.txt]
    B -->|link| C
    C -->|link| B
    C --> E[file2.txt]
```

#### **Implementa√ß√£o Java (Simula√ß√£o)**
```java
import java.util.*;

class GraphNode {
    String name;
    List<GraphNode> links = new ArrayList<>();
    
    GraphNode(String name) {
        this.name = name;
    }
    
    void addLink(GraphNode node) {
        links.add(node);
    }
}

public class GeneralGraph {
    public static void main(String[] args) {
        GraphNode root = new GraphNode("/");
        GraphNode dir1 = new GraphNode("dir1");
        GraphNode dir2 = new GraphNode("dir2");
        
        // Criar ciclo
        root.addLink(dir1);
        root.addLink(dir2);
        dir1.addLink(dir2);
        dir2.addLink(dir1); // Ciclo!
        
        // Detectar ciclos (simplificado)
        System.out.println("Grafo cont√©m ciclos? " + 
            (hasCycle(root, new HashSet<>()) ? "Sim" : "N√£o"));
    }
    
    private static boolean hasCycle(GraphNode node, Set<GraphNode> visited) {
        if (visited.contains(node)) return true;
        visited.add(node);
        for (GraphNode child : node.links) {
            if (hasCycle(child, visited)) return true;
        }
        visited.remove(node);
        return false;
    }
}
```

### **2.6 Tabela Comparativa**

| **Estrutura**       | **Vantagens**                     | **Desvantagens**                  | **Uso T√≠pico**               |
|----------------------|-----------------------------------|-----------------------------------|-------------------------------|
| **√önico N√≠vel**      | Simplicidade                      | Sem organiza√ß√£o                   | Sistemas embarcados simples   |
| **Dois N√≠veis**      | Isolamento de usu√°rios            | Compartilhamento dif√≠cil          | Sistemas multi-usu√°rio b√°sicos |
| **√Årvore**           | Organiza√ß√£o flex√≠vel              | Links n√£o-nativos                 | Maioria dos SOs modernos      |
| **Grafo Ac√≠clico**   | Compartilhamento eficiente        | Complexidade de gerenciamento     | UNIX/Linux                    |
| **Grafo Geral**      | M√°xima flexibilidade              | Risco de vazamentos               | Casos especiais               |

Cada implementa√ß√£o Java demonstra como criar e manipular essas estruturas na pr√°tica, usando tanto a API tradicional (`java.io.File`) quanto a NIO moderna (`java.nio.file`).





## **3. Implementa√ß√£o Pr√°tica em Java**

### **3.1 Navega√ß√£o em √Årvore de Diret√≥rios**
```java
import java.nio.file.*;
import java.io.*;

public class DirectoryTree {
    // == COMO RODAR ==
    // 1. javac DirectoryTree.java
    // 2. java DirectoryTree [diret√≥rio]
    
    public static void main(String[] args) throws IOException {
        Path start = Paths.get(args.length > 0 ? args[0] : ".");
        System.out.println("Estrutura a partir de: " + start.toAbsolutePath());
        
        Files.walkFileTree(start, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
                System.out.println(" ".repeat(dir.getNameCount()*2) + "üìÅ " + dir.getFileName());
                return FileVisitResult.CONTINUE;
            }
            
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                System.out.println(" ".repeat(file.getNameCount()*2) + "üìÑ " + file.getFileName());
                return FileVisitResult.CONTINUE;
            }
        });
    }
}
```

### **3.2 Gerenciamento de Links Simb√≥licos**
```java
import java.nio.file.*;

public class LinkManager {
    // == COMO RODAR ==
    // 1. javac LinkManager.java
    // 2. java LinkManager
    
    public static void main(String[] args) throws IOException {
        Path target = Paths.get("original.txt");
        Files.writeString(target, "Conte√∫do original");
        
        Path link = Paths.get("atalho.txt");
        Files.createSymbolicLink(link, target);
        
        System.out.println("Target real: " + Files.readSymbolicLink(link));
        System.out.println("Mesmo arquivo? " + Files.isSameFile(target, link));
    }
}
```

## **4. T√©cnicas Avan√ßadas**

### **4.1 Contagem de Refer√™ncias (Grafo Ac√≠clico)**
```java
class FileNode {
    String name;
    int refCount = 1;
    List<FileNode> children = new ArrayList<>();
    
    void addReference() { refCount++; }
    boolean removeReference() { return --refCount == 0; }
}
```

### **4.2 Detec√ß√£o de Ciclos (Grafo Geral)**
```java
boolean hasCycle(FileNode node) {
    return hasCycle(node, new HashSet<>());
}

boolean hasCycle(FileNode node, Set<FileNode> visited) {
    if (visited.contains(node)) return true;
    visited.add(node);
    for (FileNode child : node.children) {
        if (hasCycle(child, visited)) return true;
    }
    visited.remove(node);
    return false;
}
```

## **5. Tabela de Opera√ß√µes por Estrutura**

| **Opera√ß√£o**       | **√önico N√≠vel** | **√Årvore** | **Grafo Ac√≠clico** |
|--------------------|-----------------|------------|--------------------|
| Busca              | O(n)            | O(log n)   | O(log n)           |
| Inser√ß√£o           | O(1)            | O(log n)   | O(log n)           |
| Exclus√£o           | O(1)            | O(log n)   | O(log n)*          |
| Compartilhamento   | N√£o             | Limitado   | Completo           |
| (*) Requer coleta de l√≥gico se houver ciclos |

## **6. Exerc√≠cios Pr√°ticos**

### **Miss√£o 1: Backup Seletivo**
```java
// Implemente um sistema que:
// 1. Varre estrutura de diret√≥rios
// 2. Copia apenas arquivos modificados desde √∫ltimo backup
// 3. Mant√©m estrutura original
```

### **Miss√£o 2: Sistema de Quotas**
```java
// Crie um monitor que:
// 1. Calcula uso por usu√°rio
// 2. Considera links simb√≥licos
// 3. Bloqueia novos arquivos ao atingir limite
```

### **Miss√£o 3: Navegador Visual**
```java
// Desenvolva uma interface que:
// 1. Mostra estrutura como √°rvore
// 2. Diferencia links/reais
// 3. Permite navega√ß√£o interativa
```

## **Mindmap**

```mermaid
mindmap
  root((Sistemas de Arquivos))
    Tipos Especiais
      tmpfs ‚Üí Mem√≥ria vol√°til
      procfs ‚Üí Visualiza√ß√£o de processos
      objfs ‚Üí Acesso ao kernel
    Estruturas
      Hier√°rquicas
        √Årvore
          Caminhos absolutos/relativos
          Opera√ß√µes recursivas
        Grafo
          Links f√≠sicos/simb√≥licos
          Contagem de refer√™ncias
      N√£o-hier√°rquicas
        √önico n√≠vel
        Dois n√≠veis
    Opera√ß√µes
      Busca
        Linear
        Indexada
      Manipula√ß√£o
        Cria√ß√£o/exclus√£o
        Redirecionamento
    Java NIO
      Paths
      Files.walk
      Link simb√≥lico
    Desafios
      Ciclos
      Fragmenta√ß√£o
      Permiss√µes
```
